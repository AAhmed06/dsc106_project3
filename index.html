<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CMIP6 Climate Data Interactive Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson@3"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        select, input[type="range"] {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
            background: white;
        }

        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .time-display {
            font-weight: 600;
            color: #667eea;
            font-size: 1.1em;
        }

        .visualization-container {
            position: relative;
            background: #1a1a2e;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }


        #map {
            width: 100%;
            height: 600px;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 6px;
            color: #333;
            font-size: 0.85em;
        }

        .legend-gradient {
            height: 15px;
            width: 150px;
            border: 1px solid #ddd;
            border-radius: 2px;
            margin-bottom: 4px;
            background: linear-gradient(to right, #000, #fff);
            display: flex;
            overflow: hidden;
            align-items: center;
            justify-content: center;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            color: #666;
        }

        .legend-description {
            font-size: 0.7em;
            color: #888;
            margin-top: 4px;
            font-style: italic;
            text-align: center;
        }

        .tooltip-panel {
            background: #f8f9fa;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            min-height: 120px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .tooltip-panel h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .tooltip-panel-content {
            color: #333;
            font-size: 16px;
            line-height: 1.8;
        }

        .tooltip-panel-content.empty {
            color: #999;
            font-style: italic;
        }

        .tooltip-panel-content strong {
            color: #667eea;
            font-weight: 600;
        }

        .info-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .info-panel p {
            color: #666;
            line-height: 1.6;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
            font-size: 1.2em;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåç Things to Know About Global Warming: Higher Temperatures and Less Vegetation</h1>
        <p class="subtitle">CMIP6 Climate Data Visualization</p>

        <div class="controls">
            <div class="control-group">
                <label for="variable-select">Variable:</label>
                <select id="variable-select">
                    <option value="temperature_data.json">Global Atmospheric Temperature (ta, Emon)</option>
                    <option value="vegetation_data_small.json">Global Vegetation Carbon (cVeg, Emon)</option>
                    <option value="ocean_temperature_data.json">Ocean Temperature (bigthetao, Omon)</option>
                    <!-- <option value="snow_melt_data.json">Global Surface Snow Melt (snm, LImon)</option> -->
                </select>
            </div>
            <div class="control-group" style="flex: 1; min-width: 300px;">
                <label for="time-slider">Time Step: <span class="time-display" id="time-display">0</span></label>
                <input type="range" id="time-slider" min="0" max="0" value="0" step="1">
            </div>
            <div class="control-group">
                <label for="date-year">Year:</label>
                <select id="date-year"></select>
            </div>
            <div class="control-group">
                <label for="date-month">Month:</label>
                <select id="date-month">
                    <option value="01">January</option>
                    <option value="02">February</option>
                    <option value="03">March</option>
                    <option value="04">April</option>
                    <option value="05">May</option>
                    <option value="06">June</option>
                    <option value="07">July</option>
                    <option value="08">August</option>
                    <option value="09">September</option>
                    <option value="10">October</option>
                    <option value="11">November</option>
                    <option value="12">December</option>
                </select>
            </div>
            <div class="control-group">
                <button id="reset-zoom" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">Reset Zoom</button>
            </div>

            <div class="control-group">
              <button id="play-pause" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                ‚ñ∂ Play
              </button>
            </div>
        </div>

        <div class="visualization-container">
            <div id="map"></div>
            <div class="legend">
                <div class="legend-title" id="legend-title">Value</div>
                <div class="legend-gradient" id="legend-gradient"></div>
                <div class="legend-labels">
                    <span id="legend-min">Min</span>
                    <span id="legend-max">Max</span>
                </div>
                <div class="legend-description" id="legend-description"></div>
            </div>
        </div>

        <div class="tooltip-panel">
            <h3>Data Point Information</h3>
            <div class="tooltip-panel-content empty" id="tooltip-panel-content">
                Hover over a data point on the map (when zoomed in) to see details here.
            </div>
        </div>

        <div class="info-panel">
            <h3>About this Visualization</h3>
            <p>
                This interactive visualization displays CMIP6 (Coupled Model Intercomparison Project Phase 6) 
                historical climate data. Use the controls above to switch between different climate variables 
                and explore how they change over time. Hover over the map to see specific values at different 
                locations.
            </p>
            <p style="margin-top: 10px;">
                <strong>Data Source:</strong> CMIP6 Zarr stores hosted on Google Cloud Storage
            </p>
        </div>

        <div class="info-panel">
            <h3>Writeup</h3>
            <p>
                Rationale for Design Decisions: <br><br>

                Our project, ‚ÄúThings to Know About Global Warming: Higher Temperatures and Less Vegetation,‚Äù looks at how different 
                parts of Earth are changing over time using CMIP6 climate model data.
                We focused on three main variables: atmospheric temperature, ocean temperature, and vegetation as carbon.
                We used a world map with the Natural Earth projection because it makes it easy to see where the biggest changes are happening geographically.
                Each grid cell from the dataset is drawn as a small colored circle, which gives a good balance between detail and performance.
                An alternative we were considering was including additional variables such as ice sheet thickness and rate of melting snow, 
                but we decided against including them since their starting and ending values were largely the same and didn't contribute 
                much to the visualization. <br><br>
                
                For color, we wanted the scales to feel intuitive: <br><br> 
                Temperature variables use a red-yellow-blue gradient, so warm areas show up red and cooler areas show up blue.
                Vegetation uses green shades because it‚Äôs the most natural and instantly readable. <br><br>

                For interactivity: <br><br>
                
                We added a variable selector, a time slider, and a Play/Pause button that automatically animates through time steps so users can watch changes happen over the years.
                We also included tooltips to show the exact value and coordinates, and a dynamic legend that updates for each variable.<br><br>

                Overview of Development Process (Our group split the work based on what each person was most comfortable with): <br><br>
                Ali Ahmed: Pulled data and created the website/final visualization <br>
                Wanchen Yang: Wrote the project write-up and implemented the Play/Pause animation feature for the time slider.<br>
                Brandon Van Horn: Completed the project checkpoint, wrote part of the writeup, and cleaned up the final visualization<br>
                Emily Cai: Contributed to writeup, filtered datasets, added time range metadata in legend<br><br>

                
                We spent around 20-25 hours total working on this.
                The hardest part was definitely the data extraction step.
                The raw CMIP6 files were huge, and we ran into problems with decoding time units
                Even after fixing that, the JSON output was too big for GitHub Pages
                Most of the rest of the time was spent improving performance and making the map run smoothly.
                We used precomputed projections and throttled updates so the animation wouldn‚Äôt lag even with a large dataset.
                Overall, we learned a lot about balancing data accuracy, performance, and usability.
                Our final result lets users explore 30 years of changes in temperature and vegetation in an interactive way, and it feels satisfying to see the trends visually play out over time.

            </p>
        </div>
    </div>

    <script>
        // Global variables
        let currentData = null;
        let projection = null;
        let path = null;
        let colorScale = null;
        let svg = null;
        let worldMap = null;
        let precomputedPoints = null; // Cache for point positions
        let precomputedScales = {}; // Cache for color scales per time step
        let animationFrameId = null; // For throttling updates
        let downsamplingFactor = 2; // Show every Nth point for smoother interaction
        let zoom = null;
        let g = null; // Group for map elements
        let initialTransform = null;
        let currentTransform = d3.zoomIdentity;

        // Initialize visualization
        async function init() {
            // Set up SVG
            const container = d3.select('#map');
            const width = container.node().offsetWidth;
            const height = 600;

            svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            // Set up projection
            projection = d3.geoNaturalEarth1()
                .scale(width / 6.5)
                .translate([width / 2, height / 2]);

            path = d3.geoPath().projection(projection);

            // Create a group for all map elements (for zooming)
            g = svg.append('g');

            // Set up zoom behavior
            zoom = d3.zoom()
                .scaleExtent([1, 20])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                    currentTransform = event.transform; // Track current zoom level
                });

            svg.call(zoom);

            // Store initial transform
            initialTransform = d3.zoomIdentity;
            currentTransform = initialTransform;

            // Load world map
            try {
                const worldTopo = await d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
                worldMap = topojson.feature(worldTopo, worldTopo.objects.countries);
                drawMap();
            } catch (error) {
                console.error('Error loading world map:', error);
                d3.select('#map').html('<div class="error">Error loading world map. Please check your internet connection.</div>');
            }

            // Set up event listeners
            d3.select('#variable-select').on('change', loadData);
            d3.select('#time-slider').on('input', throttledUpdate);
            d3.select('#date-year').on('change', updateFromDate);
            d3.select('#date-month').on('change', updateFromDate);
            d3.select('#reset-zoom').on('click', resetZoom);

            // Load initial data
            loadData();
        }

        function drawMap() {
            if (!worldMap || !g) return;

            // Draw countries in the zoomable group
            g.selectAll('.country')
                .data(worldMap.features)
                .enter()
                .append('path')
                .attr('class', 'country')
                .attr('d', path)
                .attr('fill', '#2a2a3e')
                .attr('stroke', '#444')
                .attr('stroke-width', 0.5);
        }

        // Reset zoom to initial view
        function resetZoom() {
            if (!svg || !zoom) return;
            svg.transition()
                .duration(750)
                .call(zoom.transform, initialTransform);
            currentTransform = initialTransform;
        }

        async function loadData() {
            const variableFile = d3.select('#variable-select').property('value');
            
            // Clear all existing data points when switching datasets
            svg.selectAll('.data-point').remove();
            
            // Reset precomputed data
            precomputedPoints = null;
            colorScale = null;
            precomputedScales = {};
            
            // Clear tooltip panel
            d3.select('#tooltip-panel-content')
                .classed('empty', true)
                .html('Hover over a data point on the map (when zoomed in) to see details here.');
            
            // Show loading indicator without clearing the map
            const loadingIndicator = svg.append('text')
                .attr('x', svg.attr('width') / 2)
                .attr('y', svg.attr('height') / 2)
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .attr('font-size', '20px')
                .text('Loading data...');

            try {
                const data = await d3.json(variableFile);
                currentData = data;

                // Remove loading indicator
                loadingIndicator.remove();

                // Update time slider
                const maxTime = data.timeSteps.length - 1;
                d3.select('#time-slider')
                    .attr('max', maxTime)
                    .attr('value', 0);

                // Populate date dropdowns
                populateDateDropdowns(data);

                if (data.time_range) {
                    d3.select('#legend-description')
                    .text(`Data range: ${data.time_range.start} ‚Üí ${data.time_range.end} (${data.time_range.num_steps} months)`);
                } else {
                    d3.select('#legend-description')
                    .text('');
                }

                // Precompute points and scales for better performance
                precomputePoints();
                precomputeScales();

                // Initial visualization
                updateVisualization();
            } catch (error) {
                console.error('Error loading data:', error);
                loadingIndicator.remove();
                
                // Show error message
                svg.append('text')
                    .attr('x', svg.attr('width') / 2)
                    .attr('y', svg.attr('height') / 2)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#ff4444')
                    .attr('font-size', '16px')
                    .text(`Error: Could not load ${variableFile}. Please run extract_data.py first.`);
            }
        }

        // Throttled update function using requestAnimationFrame
        function throttledUpdate() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(() => {
                updateVisualization();
                updateDateFromSlider();
                animationFrameId = null;
            });
        }

        // Populate year and month dropdowns from available data
        function populateDateDropdowns(data) {
            if (!data || !data.timeSteps || data.timeSteps.length === 0) return;
            
            // --- Extract all year values from dataset ---
            const allYears = data.timeSteps
                .map(step => {
                    const match = step.time.match(/(\d{4})/);
                    return match ? parseInt(match[1]) : null;
                })
                .filter(y => y !== null);

            const minYear = d3.min(allYears);
            const maxYear = d3.max(allYears);

            // --- Populate the year dropdown with *every* year in range ---
            const yearSelect = d3.select('#date-year');
            yearSelect.selectAll('option').remove();

            for (let y = minYear; y <= maxYear; y++) {
                yearSelect.append('option')
                    .attr('value', y)
                    .text(y);
            }

            // --- Set defaults (first year + January) ---
            yearSelect.property('value', minYear);
            d3.select('#date-month').property('value', '01');

        }

        // Update visualization from date selection
        function updateFromDate() {
            if (!currentData) return;

            const selectedYear = d3.select('#date-year').property('value');
            const selectedMonth = d3.select('#date-month').property('value');

            if (!selectedYear || !selectedMonth) return;

            // Find matching time step
            let foundIndex = -1;
            for (let i = 0; i < currentData.timeSteps.length; i++) {
                const timeStr = currentData.timeSteps[i].time;
                const dateMatch = timeStr.match(/(\d{4})-(\d{2})/);
                if (dateMatch && dateMatch[1] === selectedYear && dateMatch[2] === selectedMonth) {
                    foundIndex = i;
                    break;
                }
            }

            if (foundIndex >= 0) {
                // Update slider to match found index
                d3.select('#time-slider').property('value', foundIndex);
                // Force clear old points and update visualization
                svg.selectAll('.data-point').remove();
                updateVisualization();
            }
        }

        // Update date dropdowns from slider position
        function updateDateFromSlider() {
            if (!currentData) return;

            const timeIndex = parseInt(d3.select('#time-slider').property('value'));
            const timeStep = currentData.timeSteps[timeIndex];
            
            if (timeStep && timeStep.time) {
                const dateMatch = timeStep.time.match(/(\d{4})-(\d{2})/);
                if (dateMatch) {
                    d3.select('#date-year').property('value', dateMatch[1]);
                    d3.select('#date-month').property('value', dateMatch[2]);
                }
            }
        }

        // Precompute point positions (only needs to be done once per dataset)
        function precomputePoints() {
            if (!currentData || !projection) return;

            const lons = currentData.longitude;
            const lats = currentData.latitude;
            const points = [];

            // Downsample for smoother interaction
            for (let i = 0; i < lats.length; i += downsamplingFactor) {
                for (let j = 0; j < lons.length; j += downsamplingFactor) {
                    const [x, y] = projection([lons[j], lats[i]]);
                    if (x !== null && y !== null && !isNaN(x) && !isNaN(y)) {
                        points.push({
                            x: x,
                            y: y,
                            lon: lons[j],
                            lat: lats[i],
                            latIndex: i,
                            lonIndex: j
                        });
                    }
                }
            }

            precomputedPoints = points;
        }

        // Precompute color scales for all time steps
        function precomputeScales() {
            if (!currentData) return;

            const variable = currentData.variable;
            precomputedScales = {};

            // Compute global min/max across all time steps for consistent scaling
            let globalMin = Infinity;
            let globalMax = -Infinity;

            currentData.timeSteps.forEach(timeStep => {
                const allValues = [];
                timeStep.values.forEach(row => {
                    if (row) {
                        row.forEach(val => {
                            if (val !== null && val !== undefined) {
                                allValues.push(val);
                            }
                        });
                    }
                });

                if (allValues.length > 0) {
                    const minVal = d3.min(allValues);
                    const maxVal = d3.max(allValues);
                    globalMin = Math.min(globalMin, minVal);
                    globalMax = Math.max(globalMax, maxVal);
                }
            });

            // Create color scale based on variable
            if (variable === 'ta') {
                // Temperature - bucketed colors (blue to red)
                // Create 8 temperature buckets
                const numBuckets = 8;
                const bucketSize = (globalMax - globalMin) / numBuckets;
                
                // Color palette: blue -> muted colors -> red (balanced between bright and neutral)
                const bucketColors = [
                    '#000080', // Coldest - dark blue
                    '#1e40af', // Very cold - blue
                    '#3b82f6', // Cold - medium blue
                    '#60a5fa', // Cool - light blue (muted)
                    '#fbbf24', // Moderate - muted yellow/amber
                    '#fb923c', // Warm - muted orange
                    '#ef4444', // Hot - red
                    '#991b1b'  // Hottest - dark red
                ];
                
                // Create quantized scale function
                const scaleFn = (value) => {
                    if (value === null || value === undefined || isNaN(value)) {
                        return '#cccccc'; // Gray for missing data
                    }
                    // Calculate which bucket this value falls into
                    const bucketIndex = Math.min(
                        Math.floor((value - globalMin) / bucketSize),
                        numBuckets - 1
                    );
                    return bucketColors[bucketIndex];
                };
                
                // Store bucket info for legend
                scaleFn.buckets = Array.from({length: numBuckets}, (_, i) => ({
                    min: globalMin + i * bucketSize,
                    max: globalMin + (i + 1) * bucketSize,
                    color: bucketColors[i]
                }));
                scaleFn.bucketSize = bucketSize;
                scaleFn.globalMin = globalMin;
                scaleFn.globalMax = globalMax;
                
                colorScale = scaleFn;
            } else if (variable === 'cVeg') {
                // Vegetation - green scale
                colorScale = d3.scaleSequential(d3.interpolateGreens)
                    .domain([0, globalMax]);
            } else if (variable === 'bigthetao') {
                // Ocean temperature - similar to air temp but different range
                colorScale = d3.scaleSequential(d3.interpolateRdYlBu)
                    .domain([globalMax, globalMin]);
            } else if (variable === 'snm') {
                // Snow melt - yellow-orange-red scale
                colorScale = d3.scaleSequential(d3.interpolateYlOrRd)
                    .domain([0, globalMax]);
            } else {
                // Default - viridis
                colorScale = d3.scaleSequential(d3.interpolateViridis)
                    .domain([globalMin, globalMax]);
            }

            // Update legend with global values
            updateLegend(globalMin, globalMax, variable);
        }

        function updateVisualization() {
            if (!currentData || !svg) return;

            // Ensure points are precomputed
            if (!precomputedPoints) {
                precomputePoints();
            }
            if (!colorScale) {
                precomputeScales();
            }

            const timeIndex = parseInt(d3.select('#time-slider').property('value'));
            const timeStep = currentData.timeSteps[timeIndex];

            // Update time display
            d3.select('#time-display').text(`${timeIndex} (${timeStep.time.substring(0, 10)})`);

            // Get values for current time step using precomputed point indices
            const values = timeStep.values;
            const pointsWithValues = precomputedPoints.map(point => {
                const val = values[point.latIndex] ? values[point.latIndex][point.lonIndex] : null;
                return {
                    ...point,
                    value: val
                };
            }).filter(d => d.value !== null && d.value !== undefined);

            // Use efficient data join to update existing elements
            // Use a unique key that includes time index to ensure proper removal when switching dates
            // Select from the zoomable group (g) if it exists, otherwise from svg
            const targetGroup = g && g.node() ? g : svg;
            const circles = targetGroup.selectAll('.data-point')
                .data(pointsWithValues, d => `data-${d.latIndex}-${d.lonIndex}-${currentData.variable}-${timeIndex}`);

            // Remove old points that don't match current time step
            circles.exit().remove();

            // Update existing points (just color) - this is the fast path
            circles
                .attr('fill', d => colorScale(d.value));

            // Add new points (in the zoomable group)
            const newCircles = circles.enter()
                .append('circle')
                .attr('class', 'data-point')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('r', 2)
                .attr('fill', d => colorScale(d.value))
                .attr('opacity', 0.7)
                .on('mouseover', function(event, d) {
                    // Only show tooltip when zoomed in (scale > 1.1)
                    if (currentTransform.k <= 1.1) {
                        // Update panel to show message about zooming in
                        d3.select('#tooltip-panel-content')
                            .classed('empty', true)
                            .html('Zoom in to see data point details. Use mouse wheel or pinch to zoom.');
                        return;
                    }
                    
                    const variable = currentData.variable;
                    const variableName = getVariableName(variable);
                    // Determine N/S and E/W
                    const latDir = d.lat >= 0 ? 'N' : 'S';
                    const lonDir = d.lon >= 0 ? 'E' : 'W';
                    const latAbs = Math.abs(d.lat);
                    const lonAbs = Math.abs(d.lon);
                    
                    // Update fixed tooltip panel
                    d3.select('#tooltip-panel-content')
                        .classed('empty', false)
                        .html(`
                            <div><strong>Variable:</strong> ${variableName}</div>
                            <div><strong>Latitude:</strong> ${latAbs.toFixed(2)}¬∞${latDir}</div>
                            <div><strong>Longitude:</strong> ${lonAbs.toFixed(2)}¬∞${lonDir}</div>
                            <div><strong>Value:</strong> ${d.value.toFixed(2)} ${getUnit(variable)}</div>
                        `);
                })
                .on('mouseout', function() {
                    // Keep the panel content visible (don't clear it on mouseout)
                });
            
            // Ensure all circles are in the zoomable group
            if (g && g.node()) {
                // Move any circles that ended up in svg to g
                svg.selectAll('.data-point').each(function() {
                    if (this.parentNode === svg.node()) {
                        g.node().appendChild(this);
                    }
                });
            }

            // Merge enter and update selections
            newCircles.merge(circles);
        }

        function updateLegend(minVal, maxVal, variable) {
            const variableName = getVariableName(variable);
            const unit = getUnit(variable);
            // Show variable name with code and unit in legend
            d3.select('#legend-title').html(`${variableName}<br><span style="font-size: 0.7em; font-weight: normal; color: #666;">(${variable}, ${unit})</span>`);
            
            // Add descriptive text for specific variables to clarify what the gradient means
            let description = '';
            if (variable === 'snm') {
                description = 'Lighter (yellow) = slower melting, Darker (red) = faster melting';
            } else if (variable === 'ta') {
                description = 'Blue = colder, Red = hotter';
            } else if (variable === 'cVeg') {
                description = 'Lighter = less carbon, Darker = more carbon';
            } else if (variable === 'bigthetao') {
                description = 'Blue = colder, Red = warmer';
            }
            d3.select('#legend-description').text(description);
            
            if (variable === 'ta' && colorScale.buckets) {
                // Create discrete bucket legend for temperature
                const legendGradient = d3.select('#legend-gradient');
                legendGradient
                    .attr('style', null)   // clears all inline CSS styles
                    .selectAll('*').remove(); // remove all child elements (e.g., <div> color bins)
                        
                legendGradient.html(''); // Clear existing content
                
                colorScale.buckets.forEach((bucket, i) => {
                    legendGradient.append('div')
                        .style('flex', '1')
                        .style('height', '100%')
                        .style('background-color', bucket.color)
                        .style('min-width', '0');
                });
                
                // Update min/max labels
                d3.select('#legend-min').text(minVal.toFixed(1));
                d3.select('#legend-max').text(maxVal.toFixed(1));
            } else {
                // Create CSS gradient string for other variables
                // Use more stops for smoother gradient and ensure even spacing
                const numStops = 100;
                const stops = [];
                for (let i = 0; i <= numStops; i++) {
                    const val = minVal + (maxVal - minVal) * (i / numStops);
                    const color = colorScale(val);
                    // Evenly space stops from 0% to 100%
                    stops.push(`${color} ${(i / numStops) * 100}%`);
                }
                
                const gradientStr = `linear-gradient(to right, ${stops.join(', ')})`;
                
                // Update the legend gradient div
                d3.select('#legend-gradient')
                    .html('')
                    .style('background', gradientStr)
                    .style('display', 'block');

                d3.select('#legend-min').text(minVal.toFixed(2));
                d3.select('#legend-max').text(maxVal.toFixed(2));
            }
        }

        function getVariableName(variable) {
            const names = {
                'ta': 'Global Atmospheric Temperature',
                'cVeg': 'Global Vegetation Carbon',
                'bigthetao': 'Ocean Temperature',
                'snm': 'Global Surface Snow Melt Rate'
            };
            return names[variable] || variable;
        }

        function getUnit(variable) {
            const units = {
                'ta': '¬∞C',
                'cVeg': 'kg/m¬≤',
                'bigthetao': '¬∞C',
                'snm': 'kg/m¬≤/s'
            };
            return units[variable] || '';
        }
        
        // --- Play and Pause Animation Control ---
        let isPlaying = false;
        let playInterval = null;

        d3.select("#play-pause").on("click", function() {
            if (!currentData) return;

            if (!isPlaying) {
                isPlaying = true;
                d3.select(this).text("‚è∏ Pause");
                playInterval = setInterval(() => {
                    let slider = d3.select("#time-slider");
                    let current = +slider.property("value");
                    let max = +slider.attr("max");
                    slider.property("value", (current + 1) % (max + 1));
                    throttledUpdate();
                }, 400);
            } else {
                isPlaying = false;
                clearInterval(playInterval);
                d3.select(this).text("‚ñ∂ Play");
            }
        });

        // Initialize on page load
        init();
    </script>
</body>
</html>

